<!doctype html><head><title>Minimal tQuery Page</title>
<script src="vendor/tquery/tquery-bundle.js"></script>
<script src="vendor/tquery/tquery.norequirejs.js"></script>

<script src="vendor/tquery/tquery.meshbasicmaterial.js"></script>
<script src="vendor/tquery/tquery.meshlambertmaterial.js"></script>
<script src="vendor/tquery/tquery.meshphongmaterial.js"></script>

<script src="vendor/tquery/THREEx.KeyboardState.js"></script>
<script src="vendor/tquery/tquery.keyboard.js"></script>

<script src="vendor/tquery/tquery.world.createfog.js"></script>
<script src="vendor/swfobject.js"></script>
<script src='vendor/soundmanager2/script/soundmanager2.js'></script>
<script src='vendor/underscore-min.js'></script>

<script src='js/soundmanager2Config.js'></script>
<script src='js/misc.js'></script>
<script src='js/videoData.js'></script>
<script src='js/video.js'></script>

<link rel="stylesheet" href="css/main.css">
</head>

<body id="body">
<div id="ytapiplayer"><a href="http://get.adobe.com/flashplayer/" rel="nofollow" target="_blank">Flash</a> + JavaScript needed</div>

<script>
	/**
	 * TODO
	 * * how to make the road go on ?
	 * 
	 * * bind youtube player action to game actions
	 * * some focus issues. be sure to put the focus on the game, and not youtube player
	 * * bring some particles fireworks.js
	 *   * which assets for explosion
	 * what to do on collision
	 * need the road and roadobject material plugins
	*/

	var world	= tQuery.createWorld({
		// put a custom camera
		camera	: new THREE.PerspectiveCamera(35, window.innerWidth / window.innerHeight, 0.01, 100 )
	}).boilerplate().start();

	var video = new Video();
	window.onload = init;

	world.add(world.tCamera());

	function init() {
		var videoData = new VideoData();
		// videoData.setRandom();
		videoData.setRandomByCategory('pop');
		video.setByData(videoData);
		video.embed();
	}

	//////////////////////////////////////////////////////////////////////////
	// Sounds
	var sounds	= {};
	if( true ){
		soundManager.onready(function(){
			soundManager.createSound({
				id	: "hitSphere",
				url	: "sounds/power-up.mp3",
				autoLoad: true,
				onload	: function(success){
					sounds[this.sID]	= this;
				}
			});
			soundManager.createSound({
				id	: "hitCube",
				url	: "sounds/explosion.mp3",
				autoLoad: true,
				onload	: function(success){
					console.log("loaded", success, this)
					sounds[this.sID]	= this;
				}
			});
		}.bind(this));			
	}

	// make the background transparent
	world.tRenderer().setClearColorHex(0,0);
	world.addFogExp2({density: 0.02});
	// setup camera control
	//world.getCameraControls().rangeX	/= 40/8;
	//world.getCameraControls().rangeY	/= 40/8;
	
	world.removeCameraControls();
	world.tCamera().position.set(0,1,2).normalize().setLength(3)
	world.tCamera().lookAt(new THREE.Vector3(0,0,-3.5))


	tQuery.createAmbientLight().addTo(world)
		.color(0x444444)	
	tQuery.createDirectionalLight().addTo(world)
		.color(0xCCCCCC)
		.position(-1,1,1).intensity(1);

	var roadObject3D= tQuery.createObject3D().addTo(world);


	var laneW	= 6;
	var nLane	= 6;
	var roadW	= nLane * laneW; // width
	var roadH	= 0.01; // height
	var roadD	= 50 * 30; // depth
	var nRoadObjects= 40 * 4;
	var speed	= 40;	// in zCoord/seconds

	
	// make the camera move
	world.loop().hook(function(delta, now){
		world.tCamera().position.z	-= speed*delta;
	})

	
	var track	= new Array(nRoadObjects);
	var duration	= 3.5*60;
	// generate items
	for(var i = 0; i < nRoadObjects; i++){
		var type	= Math.random() < 0.7 ? 'cube' : 'sphere';
		var item	= {
			type	: type,
			lane	: Math.floor( Math.random()*nLane ),
			absTime	: Math.random()*duration
		};
		track[i]	= item;
	}
	//track	= [{
	//	type	: 'sphere',
	//	lane	: 7,
	//	absTime	: 0
	//}];
	
	// sort it by absTime
	track.sort(function(item1, item2){  
		return item1.absTime - item2.absTime  
	});
	
	var roadObjects	= [];
	var tMaterialCube	= tQuery.createMeshLambertMaterial().color(0xFF8888).get(0);
	var tMaterialSphere	= tQuery.createMeshLambertMaterial().color(0xFFFFFF).opacity(.75).get(0);
	for(var i = 0; i < track.length; i++){
		var item	= track[i];
		var positionX	= -roadW/2 + laneW/2 + item.lane*laneW;
		var positionY	=  0;
		var positionZ	= -(item.absTime/duration)*roadD;
		if( item.type === 'cube'){
			var cubeH	= 0.75*laneW/2;
			var roadObject	= tQuery.createCube(0.75*laneW, cubeH, 0.75*laneW/2, tMaterialCube)
						.geometry().translateY(cubeH/2).back();
		}else if( item.type === 'sphere'){
			var radius = 0.75*laneW/2;		
			var roadObject	= tQuery.createSphere(radius, 32, 16, 0, Math.PI*2, 0, Math.PI/2, tMaterialSphere);
			roadObject.doubleSided = true;
			positionY -= .5; // make sphere sink a bit into ground for better looks
		}else	console.assert(false);
		roadObject.position(positionX, positionY, positionZ)
		roadObject.geometry().computeAll();

		roadObject.addTo(roadObject3D)
		roadObjects.push(roadObject)
	}

	world.loop().hook(function(delta, now){
		var playerW	= laneW/2;
		var playerH	= laneW/2;
		var playerD	= laneW/2;
		var playerPos	= world.tCamera().position.clone();
		playerPos.y	= 0;
		playerPos.z	+= playerOffset.z;
		var playerBox	= {
			min	: {
				x	: playerPos.x - playerW/2,
				y	: playerPos.y - playerH/2,
				z	: playerPos.z - playerD/2
			},
			max	: {
				x	: playerPos.x + playerW/2,
				y	: playerPos.y + playerH/2,
				z	: playerPos.z + playerD/2
			},
		};
		//console.log("playerBox", playerBox, roadObjects.length, roadObjects[0].get(0).geometry.boundingBox )
		// TODO this test against each and every road object... make it faster
		roadObjects.forEach(function(roadObject){
			var boundingBox	= roadObject.get(0).geometry.boundingBox;
			var objectPos	= roadObject.get(0).position;
			console.assert(boundingBox);
			if( playerBox.max.x < boundingBox.min.x + objectPos.x )	return;
			if( playerBox.max.y < boundingBox.min.y + objectPos.y )	return;
			if( playerBox.max.z < boundingBox.min.z + objectPos.z )	return;

			if( playerBox.min.x > boundingBox.max.x + objectPos.x )	return;
			if( playerBox.min.y > boundingBox.max.y + objectPos.y )	return;
			if( playerBox.min.z > boundingBox.max.z + objectPos.z )	return;
			
			if( roadObject.get(0).visible === false )	return;
			
			if( roadObject.get(0).geometry instanceof THREE.SphereGeometry ){
				playerOnCollideSphere(roadObject)
			}else if( roadObject.get(0).geometry instanceof THREE.CubeGeometry ){
				playerOnCollideCube(roadObject)
			}else	console.assert(false);
		})

		video.handleVolumeAutoDecrease();
	})

	// move player by keyboard
	if( false ){
		world.loop().hook(function(delta, now){
			var position	= world.tCamera().position;
			var keyboard	= tQuery.keyboard();
			var speed	= 0.1;
			if( keyboard.pressed('left') )	position.x	-= speed;
			if( keyboard.pressed('right') )	position.x	+= speed;
		});
	}

	// move player by mouse
	if( true ){
		var mouseX	= 0;
		var mouseY	= 0;
		document.body.addEventListener('mousemove', function(event){
			mouseX	= (event.clientX / window.innerWidth ) - 0.5;
			mouseY	= (event.clientY / window.innerHeight) - 0.5;
		});
		world.loop().hook(function(delta, now){
			var position	= world.tCamera().position;
			position.x	= 1.5 * mouseX * roadW;
			position.x	= Math.min(position.x, +(roadW-laneW)/2)
			position.x	= Math.max(position.x, -(roadW-laneW)/2)

			var moveBackground = false;
			var body = document.getElementById('body');
			var videoElm = document.getElementById('ytapiplayer');
			if (moveBackground && body && videoElm) {
				body.style.backgroundPosition = ( 50 - (position.x * .6) ) + '% 0';
				videoElm.style.left = ( 50 - (position.x * .25) - 9) + '%';
				videoElm.style.marginLeft = 0;
				videoElm.style.marginRight = 0;
			}
		});
	}

	world.loop().hook(function(delta, now){
		var position	= world.tCamera().position;
		position.x	= Math.min(position.x, +(roadW-laneW)/2)
		position.x	= Math.max(position.x, -(roadW-laneW)/2)
	})


	var playerBar	= tQuery.createPlane(laneW / 4, laneW / 2).addTo(world)
				.setLambertMaterial().color(0xFFFFFF).back()
	var playerOffset= new THREE.Vector3(0,0, -8);
	playerBar.position(playerOffset);
	// make playerBar follow the camera
	world.loop().hook(function(delta, now){
		var camPosition	= world.tCamera().position.clone();
		var barPosition	= camPosition.addSelf( playerOffset );
		barPosition.y	= 0.01;
		playerBar.position( barPosition );
	})
	
	function playerOnCollideSphere(roadObject){
		roadObject.get(0).visible	= false;
		video.powerUpVolume();
		sounds.hitSphere	&& sounds.hitSphere.play()
	}

	function playerOnCollideCube(roadObject){
		roadObject.get(0).visible	= false;
		video.killVolume();
		sounds.hitCube		&& sounds.hitCube.play()
	}
	
	// Road
	// - issue in the translationX ... somebody is half lane width off
	var tMaterial	= tQuery.createMeshLambertMaterial().ambient(0x444444).color(0xFFaaFF).get(0);
	var roadObject3D= tQuery.createPlane(roadW, roadD, tMaterial).addTo(roadObject3D)
			.geometry()
				.translateZ(-roadD/2)
				.back();

	// Border
	var borderW	= laneW;
	var borderH	= laneW/4;
	var tMaterial	= tQuery.createMeshLambertMaterial().ambient(0x444444).color(0xFFaaFF).get(0);
	var borderLen	= Math.sqrt(borderW*borderW+borderH*borderH);
	var borderAz	= Math.atan2(borderH, borderW);
	var leftBorder	= tQuery.createPlane(borderLen, roadD, tMaterial).addTo(roadObject3D)
			.geometry().rotateZ(-borderAz).back()
			.translateX(-roadW/2 - borderW/2)
			.translateY(borderH/2)
			.translateZ(-roadD/2)
	var rightBorder	= tQuery.createPlane(borderLen, roadD, tMaterial).addTo(roadObject3D)
			.geometry().rotateZ(+borderAz).back()
			.translateX(+roadW/2 + borderW/2)
			.translateY(borderH/2)
			.translateZ(-roadD/2)

	// sideWalk
	var walkW	= 10;
	var tMaterial	= tQuery.createMeshLambertMaterial().ambient(0x444444).color(0xFFaaFF).get(0);
	var leftWalk	= tQuery.createPlane(walkW, roadD, tMaterial).addTo(roadObject3D)
			.translateX(-roadW/2 - borderW - walkW/2)
			.translateY(borderH)
			.translateZ(-roadD/2)
	var rightWalk	= tQuery.createPlane(walkW, roadD, tMaterial).addTo(roadObject3D)
			.translateX(+roadW/2 + borderW + walkW/2)
			.translateY(borderH)
			.translateZ(-roadD/2)
</script>
</body>